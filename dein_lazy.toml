[[plugins]]
repo = 'mechatroner/rainbow_csv'
on_ft = 'csv'

[[plugins]]
repo = 'preservim/nerdtree'
hook_add = '''
    nnoremap <silent> <leader>n :NERDTreeFocus<CR>
'''

[[plugins]]
repo = 'junegunn/fzf'
build = './install --bin'
merged = '0'

[[plugins]]
repo = 'junegunn/fzf.vim'
depends = 'fzf'
on_cmd = [
    'Files',
    'GFiles',
    'GFiles?',
    'Buffer',
    'History',
    'Rg'
]
hook_add = '''
    let $FZF_DEFAULT_OPTS="--layout=reverse"
    "let $FZF_DEFAULT_COMMAND="rg --files --hidden --glob '!.git/**'"
    let g:fzf_layout = {'up':'~90%', 'window': { 'width': 0.8, 'height': 0.8, 'yoffset':0.5, 'xoffset':0.5, 'border': 'sharp' }}
    nnoremap <silent> <leader>f :Files<CR>
    nnoremap <silent> <leader>g :GFiles<CR>
    nnoremap <silent> <leader>G :GFiles?<CR>
    nnoremap <silent> <leader>b :Buffer<CR>
    nnoremap <silent> <leader>h :History<CR>
    nnoremap <silent> <leader>r :Rg<CR>
'''

[[plugins]]
repo = 'tpope/vim-surround'
on_map = ['ysw', 'cs', 'ds', 'S']
# ToDo: モードに対応する

[[plugins]]
repo = 'tpope/vim-fugitive'
on_cmd = 'Git'

[[plugins]]
repo = 'iamcco/markdown-preview.nvim'
on_ft = ['markdown', 'pandoc.markdown', 'rmd']
build = 'sh -c "cd app && npx --yes npm install"'
hook_add = '''
    nnoremap <Leader>md <Plug>MarkdownPreview
'''

[[plugins]]
repo = 'github/copilot.vim'
on_cmd = 'Copilot'
hook_source = '''
    let g:copilot_no_maps = v:true
    let g:copilot_hide_during_completion = 0
    imap <silent><expr> <C-g> copilot#Accept()
    imap <silent><expr> <C-n> copilot#Next()
    imap <silent><expr> <C-p> copilot#Previous()
'''

[[plugins]]
repo = 'vim-denops/denops.vim'

[[plugins]]
repo = 'vim-skk/skkeleton'
depends = ['denops.vim']
on_map = { ict = '<Plug>(skkeleton-'}
hook_add = '''
    inoremap <C-j>  <Plug>(skkeleton-toggle)
    cnoremap <C-j>  <Plug>(skkeleton-toggle)
    tnoremap <C-j>  <Plug>(skkeleton-toggle)
    nnoremap <C-j> i<Plug>(skkeleton-enable)
'''
hook_source = '''
    call skkeleton#config(#{
        \   globalDictionaries    : ['~/.skk/SKK-JISYO.L'->expand()],
        \   databasePath          : '~/.cache/skk/skkeleton.db'->expand(),
        \   completionRankFile    : '~/.skk/rank.json'->expand(),
        \   sources               : ['deno_kv', 'google_japanese_input'],
        \   registerConvertResult : v:true,
        \   eggLikeNewline        : v:true,
        \ })

    call add( g:skkeleton#mapped_keys, 'l' )
    call skkeleton#register_keymap('input', 'l', 'abbrev')

    ""autocmd MyAutoCmd User skkeleton-enable-pre call s:skkeleton_pre()
    ""function! s:skkeleton_pre() abort
    ""    " Overwrite sources
    ""    let s:prev_buffer_config = ddc#custom#get_buffer()
    ""    call ddc#custom#patch_buffer({
    ""    \    'sources'      : ['around', 'skkeleton'],
    ""    \    'sourceOptions':{
    ""    \        _: {
    ""    \            'keywordPattern': '[ァ-ヮア-ンー]+',
    ""    \           },
    ""    \                    },
    ""    \})
    ""endfunction

    ""autocmd MyAutoCmd User skkeleton-disable-pre call s:skkeleton_post()
    ""function! s:skkeleton_post() abort
    ""    if 's:prev_buffer_config'->exists()
    ""        " Restore sources
    ""        call ddc#custom#set_buffer(s:prev_buffer_config)
    ""    endif
    ""endfunction

    ""autocmd myAutoCmd User skkeleton-mode-changed call s:skkeleton_changed()
    ""function! s:skkeleton_changed() abort
    ""    const mode = g:skkeleton#mode
    ""    if     mode ==# 'hira'
    ""        highlight Cursor     gui=NONE guibg=#80403f guifg=fg
    ""    elseif mode ==# 'kata'
    ""        highlight Cursor     gui=NONE guibg=#f04060 guifg=fg
    ""    elseif mode ==# 'hankaku'
    ""        highlight Cursor     gui=NONE guibg=#60a060 guifg=fg
    ""    elseif mode ==# 'zenkaku'
    ""        highlight Cursor     gui=NONE guibg=#60f060 guifg=fg
    ""    else
    ""        highlight Cursor     gui=NONE guibg=#606060 guifg=fg
    ""    endif
    ""endfunction

    call skkeleton#initialize()
'''

#_____________________________________________________________ Start ddc
[[plugins]]
repo = 'Shougo/ddc.vim'
on_event = 'InsertEnter'
depends = ['denops.vim']
hook_source = '''
    call ddc#custom#patch_global('ui', 'pum')
    call ddc#custom#patch_global('sources', [
    \                                        'around',
    \                                        'vim-lsp',
    \                                        'dictionary',
    \                                        'file',
    \                                        ])
    call ddc#custom#patch_global('sourceOptions', {
    \   '_'        : {
    \       'matchers'              : ['matcher_head'],
    \       'sorters'               : ['sorter_rank'],
    \       'converters'            : ['converter_remove_overlap'],
    \                },
    \  'around'    : {
    \       'mark'                  : '[Around]'
    \                },
    \  'vim-lsp'   : {
    \       'mark'                  : '[LSP]',
    \       'matchers'              : ['matcher_head'],
    \       'forceCompletionPattern': '\.|:|->|"\w+/*'
    \                },
    \  'dictionary': {
    \       'mark'                  : '[Dict]',
    \                },
    \  'file'      : {
    \       'mark'                  : '[File]',
    \       'isVolatile'            : v:true,
    \       'forceCompletionPattern': '\S/\S*'
    \                },
    \ })
    call ddc#custom#patch_global('sourceParams', {
    \  'dictionary': {
    \       'dictPaths'             : ['/usr/share/dict/american-english'],
    \       'smartCase'             : v:true,
    \       'showMenu'              : v:false,
    \                },
    \ })
    call ddc#enable()

    inoremap <silent><expr> <TAB>
        \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
        \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
        \'<TAB>' : ddc#map#manual_complete()
    inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
    inoremap <C-n>   <Cmd>call pum#map#insert_relative(+1)<CR>
    inoremap <C-p>   <Cmd>call pum#map#insert_relative(-1)<CR>
    inoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
    inoremap <C-e>   <Cmd>call pum#map#cancel()<CR>
'''

[[plugins]]
repo = 'Shougo/pum.vim'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-ui-pum'
on_source = 'ddc.vim'
hook_add = '''
    call pum#set_option({
    \            'max_width': 50,
    \           'max_height': 10,
    \        'preview_width': 50,
    \       'preview_height': 10,
    \ })
'''

[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-matcher_head'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-converter_remove_overlap'
on_source = 'ddc.vim'

[[plugins]]
repo = 'shun/ddc-source-vim-lsp'
on_source = 'ddc.vim'

[[plugins]]
repo = 'LumaKernel/ddc-file'
on_source = 'ddc.vim'

[[plugins]]
repo = 'matsui54/ddc-dictionary'
on_source = 'ddc.vim'

#_____________________________________________________________ End ddc

#_____________________________________________________________ Start treesitter
[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
merged = '0'
on_event = 'BufRead'
hook_post_update = 'TSUpdate'
lua_post_source = '''
    require( 'nvim-treesitter.configs' ).setup {
        highlight = {enable = true},
        indent    = {enable = true},
    }
'''

[[plugins]]
repo = 'nvim-treesitter/playground'
depends = 'nvim-treesitter'
on_cmd = ['TSPlaygroundToggle']
#_____________________________________________________________ End treesitter

#_____________________________________________________________ Start LSP
[[plugins]]
repo = 'prabirshrestha/async.vim'
on_source = 'vim-lsp'

[[plugins]]
repo = 'prabirshrestha/vim-lsp'
merged = '0'
on_event = 'BufRead'

[[plugins]]
repo = 'mattn/vim-lsp-settings'
on_source = 'vim-lsp'
#_____________________________________________________________ End LSP

#_____________________________________________________________ Start LaTeX
[plugins.ftplugin]
tex = '''
    autocmd MyAutoCmd FileType tex call s:TeXKeymap()
    autocmd MyAutoCmd FileType tex
        \ autocmd BufWritePre <buffer> call s:FixPunctuation()
    function! s:TeXKeymap() abort
        inoremap $ $$<LEFT>
        inoremap ` `'<LEFT>
    endfunction
    function! s:FixPunctuation() abort
        let l:pos = getpos('.')
        silent! execute ':%s/。/./g'
        silent! execute ':%s/、/,/g'
        silent! execute ':%s/\\\@<!\s\+$//'
        setlocal modified
        call setpos('.', l:pos)
    endfunction
'''
[[plugins]]
repo = 'Omochice/TeXoutline.vim'
hook_add = '''
    nnoremap <silent> <leader>> :TeXOutline<CR>
'''

#[[plugins]]
#repo = 'kamecha/denops-dbus_synctex'
#on_ft = ['tex']
#depends = ['denops.vim']
#on_cmd = 'DbusSyncView'
#hook_add = '''
#    autocmd MyAutoCmd FileType tex call s:TexKeymap()
#
#    function! s:TexKeymap() abort
#        nnoremap <buffer> <Leader>lx <Cmd>:DbusSyncView<CR>
#    endfunction
#'''
#hook_post_source = '''
#    function s:syncSource(texPath, line, col, time) abort
#        call cursor([a:line, a:col < 0 ? 1 : a:col])
#    endfunction
#
#    function s:initSyncTex() abort
#        " create bus for link evince and vim
#        call dbus_synctex#createSessionBus()
#        " register syncSource callback to denops
#        call dbus_synctex#registerCallback(function("s:syncSource"))
#        " register depons's syncSource callback to evince.
#        " if evince window is not opened, this function does nothing.
#        " for command version, use :DbusRegisterSyncSource
#        call dbus_synctex#registerSyncSource(dbus_synctex#getPdfpathCWD())
#    endfunction
#
#    autocmd MyAutoCmd User DenopsPluginPost:dbus_synctex call s:initSyncTex()
#'''
#_____________________________________________________________ End LaTeX

[[plugins]]
repo = 'junegunn/vim-easy-align'
on_map = '<Plug>(EasyAlign)'
hook_add = '''
    xnoremap <silent>ga <Plug>(EasyAlign)
'''

[[plugins]]
repo = 'easymotion/vim-easymotion'
on_cmd = '<Plug>(easymotion-)'
hook_add = '''
    let g:EasyMotion_do_mapping = 0 "Disable default mappings
    let g:EasyMotion_smartcase = 1 "Turn on case insensitive feature
'''

[[plugins]]
repo = 'hrsh7th/vim-searchx'
on_cmd = ['/', '?']
hook_add = '''
    " Overwrite / and ?
    nnoremap ? <Cmd>call searchx#start({'dir': 0})<CR>
    nnoremap / <Cmd>call searchx#start({'dir': 1})<CR>
    xnoremap ? <Cmd>call searchx#start({'dir': 0})<CR>
    xnoremap / <Cmd>call searchx#start({'dir': 1})<CR>
    cnoremap ; <Cmd>call searchx#select()<CR>

    " Move to next/prev match.
    nnoremap     N <Cmd>call searchx#prev_dir()<CR>
    nnoremap     n <Cmd>call searchx#next_dir()<CR>
    xnoremap     N <Cmd>call searchx#prev_dir()<CR>
    xnoremap     n <Cmd>call searchx#next_dir()<CR>
    nnoremap <C-k> <Cmd>call searchx#prev()<CR>
    nnoremap <C-j> <Cmd>call searchx#next()<CR>
    xnoremap <C-k> <Cmd>call searchx#prev()<CR>
    xnoremap <C-j> <Cmd>call searchx#next()<CR>
    cnoremap <C-k> <Cmd>call searchx#prev()<CR>
    cnoremap <C-j> <Cmd>call searchx#next()<CR>

    " Clear highlights
    nnoremap <ESC><ESC> <Cmd>call searchx#clean()<CR>

    let g:searchx = {}

    " Auto jump if the recent input matches to any marker.
    let g:searchx.auto_accept = v:true

    " The scrolloff value for moving t next/prev
    let g:searchx.scrolloff = &scrolloff

    " Enable scrolling animation
    let g:searchx.scrolltime = 500

    " Enable auto nohlsearch after cursor moved
    let g:searchx.nohlsearch = {}
    let g:searchx.nohlsearch.jump = v:true

    " Marker characters
    let g:searchx.markers = split('ASDFGHJKLZXCVBNMQWERTYUIOP', '.\zs')

    " Convert search patter.
    function g:searchx.convert(input) abort
        if a:input !~# '\k'
            return '\V' .. a:input
        endif
        return a:input[0] .. substitute(a:input[1:], '\\\@<! ', '.\\{-}', 'g')
    endfunction
'''
