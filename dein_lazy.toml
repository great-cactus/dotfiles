[[plugins]]
repo = 'mechatroner/rainbow_csv'
on_ft = 'csv'

[[plugins]]
repo = 'preservim/nerdtree'
hook_add = '''
    nnoremap <silent> <leader>n :NERDTreeToggle<CR>
'''

[[plugins]]
repo = 'nvim-tree/nvim-web-devicons'

# [[plugins]]
# repo = 'hpjansson/chafa'
# build = './autogen.sh && make && sudo make install'

[[plugins]]
repo = 'atanunq/viu'
build = 'cargo install --path .'

[[plugins]]
repo = 'jstkdng/ueberzugpp'

[[plugins]]
repo = 'junegunn/fzf'
build = './install --bin'
frozen = '1'
merged = '0'

[[plugins]]
repo = 'ibhagwan/fzf-lua'
# depends = ['fzf', 'nvim-web-devicons', 'chafa', 'viu', 'ueberzugpp']
depends = ['fzf', 'nvim-web-devicons', 'viu', 'ueberzugpp']
on_map = {n = [
               '<leader>ff',
               '<leader>fg',
               '<leader>fG',
               '<leader>fb',
               '<leader>fh',
               '<leader>fr',
]}
lua_source = '''
local fzf = require('fzf-lua')
vim.keymap.set('n', '<leader>ff', fzf.files)
vim.keymap.set('n', '<leader>fg', fzf.git_files)
vim.keymap.set('n', '<leader>fG', fzf.git_status)
vim.keymap.set('n', '<leader>fb', fzf.buffers)
vim.keymap.set('n', '<leader>fh', fzf.oldfiles)
vim.keymap.set('n', '<leader>fr', fzf.live_grep)

fzf.setup({
    winopts = {
        height = 0.8,
        width = 0.8,
        row = 0.35,
        col = 0.5,
        border = 'rounded'
    },
    fzf_opts = {
        ['--layout'] = 'reverse'
    },
    files = {
        fd_opts = '--color=never --type f --hidden --follow --exclude .git'
    },
    previewers = {
        builtin = {
            extensions = {
                ["png"] = { "viu", "-b" },
                ["jpg"] = { "ueberzug" },
            },
            ueberzug_scaler = "cover",
        },
    },
})
'''

# [[plugins]]
# repo = 'preservim/vim-indent-guides'
# on_ft = ['markdown', 'python', 'fortran', 'c++', 'tex', 'toml', 'lua']
# hook_add = '''
#     let g:indent_guides_enable_on_vim_startup = 1
# '''
# hook_source = '''
#     let g:indent_guides_auto_colors = 0
#     let g:indent_guides_start_level = 2
#     let g:indent_guides_guide_size = 1
#     let g:indent_guides_exclude_filetypes = ['help', 'nerdtree', 'terminal', 'quickfix']
#     autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=#d7d7d7 ctermbg=254
#     autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=#e4e4e4 ctermbg=8
# '''

[[plugins]]
repo = 'tpope/vim-surround'
on_map = ['ysw', 'cs', 'ds', 'S']
# TODO: モードに対応する

# [[plugins]]
# repo = 'tpope/vim-fugitive'
# on_cmd = 'Git'

[[plugins]]
repo = 'iamcco/markdown-preview.nvim'
on_map = { ictn = '<Plug>MarkdownPreview'}
build = 'sh -c "cd app && npx --yes npm install"'
hook_add = '''
nnoremap <silent> <leader>md <Plug>MarkdownPreview
'''

#_____________________________________________________________ Start Copilot
[[plugins]]
repo = 'github/copilot.vim'
on_cmd = 'Copilot'
hook_source = '''
    let g:copilot_node_command = expand( '~/.nodejs/bin/node' )
    let g:copilot_no_maps = v:true
    let g:copilot_hide_during_completion = 0
    imap <silent><expr> <C-g> copilot#Accept()
    imap <silent><expr> <C-n> copilot#Next()
    imap <silent><expr> <C-p> copilot#Previous()

    let g:copilot_filetypes = #{
        \   gitcommit: v:true,
        \   markdown: v:true,
        \   python: v:true,
        \   vim: v:true,
        \}
'''

[[plugins]]
repo = 'nvim-lua/plenary.nvim'

[[plugins]]
repo = 'CopilotC-Nvim/CopilotChat.nvim'
on_map = '<leader>cop'
depends = ['copilot.vim', 'plenary.nvim']
branch = 'main'
hook_add = '''
    nnoremap <leader>cop :CopilotChatOpen<CR>
'''
hook_post_source = '''
set completeopt+=noinsert,popup
nnoremap <leader>cop :CopilotChatOpen<CR>
lua << EOF
require('dein/copilotChat')
EOF
'''
#_____________________________________________________________ End Copilot

[[plugins]]
repo = 'vim-denops/denops.vim'
hook_source = '''
    let g:denops#server#deno_args = [
        \    '-q',
        \    '-A',
        \    '--unstable-kv',
        \]
'''

[[plugins]]
repo = 'skk-dev/dict'

[[plugins]]
repo = 'vim-skk/skkeleton'
depends = ['denops.vim', 'dict']
denops_wait = false
on_map = { ictn = '<Plug>(skkeleton-'}
hook_add = '''
    inoremap <C-j>  <Plug>(skkeleton-toggle)
    cnoremap <C-j>  <Plug>(skkeleton-toggle)
    tnoremap <C-j>  <Plug>(skkeleton-toggle)
    nnoremap <C-j> i<Plug>(skkeleton-enable)
'''
hook_source = '''
    call skkeleton#config(#{
        \   globalDictionaries    : ['~/.cache/dein/repos/github.com/skk-dev/dict/SKK-JISYO.L'->expand()],
        \   databasePath          : '~/.cache/skk/skkeleton.db'->expand(),
        \   completionRankFile    : '~/.skk/rank.json'->expand(),
        \   sources               : ['deno_kv', 'google_japanese_input'],
        \   registerConvertResult : v:true,
        \   eggLikeNewline        : v:true,
        \ })

    autocmd MyAutoCmd User skkeleton-enable-pre call s:skkeleton_pre()
    function! s:skkeleton_pre() abort
        " Overwrite sources
        let s:prev_buffer_config = ddc#custom#get_buffer()
        call ddc#custom#patch_buffer({
        \    'sources'      : ['around', 'skkeleton'],
        \    'sourceOptions':{
        \        '_' : {
        \            'keywordPattern': '[ァ-ヮア-ンー]+',
        \              },
        \                    },
        \})
    endfunction

    autocmd MyAutoCmd User skkeleton-disable-pre call s:skkeleton_post()
    function! s:skkeleton_post() abort
        if 's:prev_buffer_config'->exists()
            " Restore sources
            call ddc#custom#set_buffer(s:prev_buffer_config)
        endif
    endfunction

    call skkeleton#initialize()
'''

[[plugins]]
repo = 'delphinus/skkeleton_indicator.nvim'
on_source = 'skkeleton'
lua_source = '''
    require('skkeleton_indicator').setup{}
'''

#_____________________________________________________________ Start ddc
[[plugins]]
repo = 'Shougo/ddc.vim'
on_event = 'InsertEnter'
depends = ['denops.vim']
hook_source = '''
    call ddc#custom#patch_global('ui', 'pum')
    call ddc#custom#patch_global('sources', [
    \                                        'lsp',
    \                                        'file',
    \                                        'around',
    \                                        'buffer',
    \                                        'rg',
    \                                        'dictionary',
    \                                        ])
    call ddc#custom#patch_global('sourceOptions', {
    \   '_'        : {
    \       'matchers'              : ['matcher_fuzzy'],
    \       'sorters'               : ['sorter_fuzzy'],
    \       'converters'            : ['converter_fuzzy'],
    \                },
    \  'lsp' : {
    \       'isVolatile'            : v:true,
    \       'mark'                  : '[LSP]',
    \       'forceCompletionPattern': '\.|:|->|"\w+/*'
    \                },
    \  'around'    : {
    \       'mark'                  : '[Around]'
    \                },
    \  'buffer'    : {
    \       'mark'                  : '[Buf]'
    \                },
    \  'rg'    : {
    \       'mark'                  : '[ripgrep]'
    \                },
    \  'dictionary': {
    \       'mark'                  : '[Dict]'
    \                },
    \  'file'      : {
    \       'mark'                  : '[File]',
    \       'isVolatile'            : v:true,
    \       'forceCompletionPattern': '\S/\S*'
    \                },
    \ })

    call ddc#custom#patch_global('sourceParams', {
    \  'dictionary': {
    \       'dictPaths'             : ['/usr/share/dict/american-english'],
    \       'smartCase'             : v:true,
    \       'showMenu'              : v:false,
    \                },
    \  'lsp' : {
    \       'snippetEngine': denops#callback#register({
    \           body -> luasnip#anonymous(body)
    \       }),
    \       'enableResolveItem': v:true,
    \       'enableAdditionalTextEdit': v:true,
    \       'confirmBehavior': 'replace',
    \     },
    \ })

    call ddc#enable()

    inoremap <silent><expr> <TAB>
        \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
        \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
        \'<TAB>' : ddc#map#manual_complete()
    inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
    inoremap <C-n>   <Cmd>call pum#map#insert_relative(+1)<CR>
    inoremap <C-p>   <Cmd>call pum#map#insert_relative(-1)<CR>
    inoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
    inoremap <C-e>   <Cmd>call pum#map#cancel()<CR>
'''

[[plugins]]
repo = 'Shougo/pum.vim'
on_source = 'ddc.vim'

[[plugins]]
repo = 'shutils/ddc-source-obsidian'
on_source = 'ddc.vim'
on_if = 'expand("%:p") =~# "^" . expand("$OBSIDIAN_PATH") . ".*\\.md$"'
hook_source = '''
call ddc#custom#patch_filetype('markdown', #{
  \ sources: [ 'obsidian_tag', 'obsidian_link' ],
  \ sourceParams: #{
  \   obsidian_tag: #{ vault: expand('$OBSIDIAN_PATH') },
  \   obsidian_link: #{ vault: expand('$OBSIDIAN_PATH') },
  \},
  \ sourceOptions: #{
  \  obsidian_tag: #{
  \    mark: '[OBS-TAG]',
  \  },
  \  obsidian_link: #{
  \    mark: '[OBS-LINK]',
  \  },
  \},
\})
'''

[[plugins]]
repo = 'Shougo/ddc-ui-pum'
on_source = 'ddc.vim'
hook_add = '''
    call pum#set_option({
    \            'max_width': 50,
    \           'max_height': 10,
    \        'preview_width': 50,
    \       'preview_height': 10,
    \ })
'''
[[plugins]]
repo = 'Shougo/ddc-buffer'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-rg'
on_source = 'ddc.vim'

[[plugins]]
repo = 'tani/ddc-fuzzy'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'LumaKernel/ddc-file'
on_source = 'ddc.vim'

[[plugins]]
repo = 'matsui54/ddc-dictionary'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-lsp'
on_source = 'ddc.vim'

[[plugins]]
repo = 'uga-rosa/ddc-source-lsp-setup'
on_source = 'ddc.vim'

[[plugins]]
repo = 'g-ctus/ddc-source-luasnip'
on_source = 'ddc.vim'
depends = ['ddc-source-lsp-setup']
lua_post_source = '''
require("ddc_source_lsp_setup").setup()
'''

#_____________________________________________________________ End ddc

#_____________________________________________________________ Start treesitter
[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
merged = '0'
on_event = 'BufReadPost'
hook_post_update = 'TSUpdate'
lua_source = '''
require( 'nvim-treesitter.configs' ).setup {
    highlight = {enable = true, disable = {"fortran"}},
    indent    = {enable = true, disable = {"fortran"}},
    injection = {enable = true},
    fold = {
        enable = true,
        indent_level = 2,
        scan = 100,
    },
}

vim.treesitter.language.register('latex', 'tex')
vim.wo.foldmethod = 'expr'
vim.wo.foldexpr = 'v:lua.vim.treesitter.foldexpr()'
vim.opt.foldlevel = 99

-- Setup filetype-specific fold levels
vim.api.nvim_create_autocmd("FileType", {
    pattern = {"python"},
    callback = function()
        vim.wo.foldlevel = 3
    end,
})

vim.api.nvim_create_autocmd("FileType", {
    pattern = {"tex", "latex"},
    callback = function()
        vim.wo.foldlevel = 2
    end,
})

vim.api.nvim_create_autocmd("FileType", {
    pattern = {"markdown"},
    callback = function()
        vim.wo.foldlevel = 3
    end,
})
'''

[[plugins]]
repo = 'nvim-treesitter/playground'
depends = 'nvim-treesitter'
on_cmd = ['TSPlaygroundToggle']


[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter-context'
depends = 'nvim-treesitter'
on_cmd = ['TSContextToggle', 'TSContextEnable']
hook_add = '''
nnoremap <silent> <leader>tct :TSContextToggle<CR>
'''
lua_source = '''
require'treesitter-context'.setup{
  enable = true, -- Enable this plugin (Can be enabled/disabled later via commands)
  multiwindow = false, -- Enable multiwindow support.
  max_lines = 5, -- How many lines the window should span. Values <= 0 mean no limit.
  min_window_height = 0, -- Minimum editor window height to enable context. Values <= 0 mean no limit.
  line_numbers = true,
  multiline_threshold = 20, -- Maximum number of lines to show for a single context
  trim_scope = 'outer', -- Which context lines to discard if `max_lines` is exceeded. Choices: 'inner', 'outer'
  mode = 'cursor',  -- Line used to calculate context. Choices: 'cursor', 'topline'
  -- Separator between context and content. Should be a single character string, like '-'.
  -- When separator is set, the context will only show up when there are at least 2 lines above cursorline.
  separator = nil,
  zindex = 20, -- The Z-index of the context window
  on_attach = function(buf)
    vim.notify("treesitter-context enabled", vim.log.levels.INFO, {})
    return true
  end,
  on_detach = function(buf)
    vim.notify("treesitter-context disabled", vim.log.levels.INFO, {})
    return true
  end,
}
'''
#_____________________________________________________________ End treesitter

#_____________________________________________________________ Start LSP with mason.nvim and builtin LSP

[[plugins]]
repo = 'neovim/nvim-lspconfig'
on_event = ['BufReadPre', 'BufNewFile']
depends = ['mason.nvim']
merged = '0'
lua_source = '''
-- LSP keymaps via LspAttach autocmd
vim.api.nvim_create_autocmd('LspAttach', {
    callback = function(event)
        local bufnr = event.buf
        local client = vim.lsp.get_client_by_id(event.data.client_id)

        local function map(mode, lhs, rhs)
            vim.keymap.set(mode, lhs, rhs, { buffer = bufnr, noremap = true, silent = true })
        end

        -- Navigation
        map('n', 'gd', vim.lsp.buf.definition)
        map('n', 'gD', vim.lsp.buf.declaration)
        map('n', 'gr', vim.lsp.buf.references)
        map('n', 'gI', vim.lsp.buf.implementation)
        map('n', 'gy', vim.lsp.buf.type_definition)

        -- Documentation
        map('n', 'K', vim.lsp.buf.hover)
        map('n', 'gK', vim.lsp.buf.signature_help)
        -- map('i', '<C-k>', vim.lsp.buf.signature_help)

        -- Rename
        map('n', '<F2>', vim.lsp.buf.rename)

        -- Code actions
        map('n', '<leader>ca', vim.lsp.buf.code_action)
        map('x', '<leader>ca', vim.lsp.buf.code_action)

        -- Formatting
        if client.supports_method('textDocument/formatting') then
            map('n', 'gf', function() vim.lsp.buf.format({ async = true }) end)
        end

        if client.supports_method('textDocument/rangeFormatting') then
            map('x', 'gf', function() vim.lsp.buf.format({ async = true }) end)
        end

        -- Document symbols
        map('n', 'gO', vim.lsp.buf.document_symbol)

        -- Diagnostics
        map('n', '[d', vim.diagnostic.goto_prev)
        map('n', ']d', vim.diagnostic.goto_next)
        map('n', '<leader>e', vim.diagnostic.open_float)
        map('n', '<leader>q', vim.diagnostic.setloclist)

        -- Document highlight
        if client.supports_method('textDocument/documentHighlight') then
            local highlight_group = vim.api.nvim_create_augroup('lsp_document_highlight_' .. bufnr, { clear = true })

            vim.api.nvim_create_autocmd({'CursorHold', 'CursorHoldI'}, {
                buffer = bufnr,
                group = highlight_group,
                callback = vim.lsp.buf.document_highlight,
            })

            vim.api.nvim_create_autocmd({'CursorMoved', 'CursorMovedI'}, {
                buffer = bufnr,
                group = highlight_group,
                callback = vim.lsp.buf.clear_references,
            })
        end
    end,
})


-- Configure diagnostics
vim.diagnostic.config({
    virtual_text = false,
    virtual_line = false,
    signs = {
        text = {
            [vim.diagnostic.severity.ERROR] = '󰅚 ',
            [vim.diagnostic.severity.WARN] = '󰀪 ',
            [vim.diagnostic.severity.HINT] = '󰌶',
            [vim.diagnostic.severity.INFO] = ' ',
        },
    },
    update_in_insert = false,
    underline = true,
    severity_sort = true,
    float = {
        focusable = false,
        style = "minimal",
        border = "rounded",
        source = "always",
        header = "",
        prefix = "",
    },
})

vim.api.nvim_create_autocmd("CursorHold", {
    callback = function()
        vim.diagnostic.open_float({
            focusable = false,
            close_events = {
                "BufLeave",
                "CursorMoved",
                "InsertEnter",
                "FocusLost"
            },
            border = 'rounded',
            style = "minimal",
            source = 'always'
        })
    end
})
vim.opt.updatetime = 250

vim.lsp.set_log_level("OFF")
require('lsp')
'''

[[plugins]]
repo = 'williamboman/mason.nvim'
merge = '0'
lua_source = '''
require('mason').setup({
    ui = {
        border = 'rounded',
        width = 0.8,
        height = 0.8,
    },
    log_level = vim.log.levels.INFO,
    max_concurrent_installers = 5,
})
'''

[[plugins]]
repo = 'williamboman/mason-lspconfig.nvim'
depends = ['nvim-lspconfig', 'mason.nvim']
lua_source = '''
require('mason-lspconfig').setup({
    ensure_installed = {
        'pylsp',
        'texlab',
        'ltex',
        'efm',
        'lua_ls',
    },
    automatic_installation = true,
})
'''
#_____________________________________________________________ End LSP with mason.nvim and builtin LSP

[[plugins]]
repo = 'junegunn/vim-easy-align'
on_map = '<Plug>(EasyAlign)'
hook_add = '''
    xnoremap <silent>ga <Plug>(EasyAlign)
'''

[[plugins]]
repo = 'easymotion/vim-easymotion'
on_cmd = '<Plug>(easymotion-)'
hook_add = '''
    let g:EasyMotion_do_mapping = 0 "Disable default mappings
    let g:EasyMotion_smartcase = 1 "Turn on case insensitive feature
'''

#_____________________________________________________________ Start vim-quickrun
[[plugins]]
repo = 'Shougo/vimproc.vim'
build = 'make'
on_source = 'vim-quickrun'

[[plugins]]
repo = 'thinca/vim-quickrun'
on_cmd = '<F5>'
hook_add = '''
    nnoremap <silent> <F5> :QuickRun<CR>
'''
hook_source = '''
    " Kill the process by <Ctrl-C>
    function! s:sweep_and_message()
        call quickrun#sweep_sessions()
        echo "Killed"
        return ""
    endfunction
    nnoremap <expr><silent> <C-c> quickrun#is_running() ? <SID>sweep_and_message(): "\<C-c>"

    " Custom outputter to use vim.notify
    let s:outputter = {
    \   "name" : "notify",
    \   "kind" : "outputter",
    \}

    function! s:outputter.init(session)
    endfunction

    function! s:outputter.output(data, session)
        " エラー出力かどうかを確認
        let l:is_error = has_key(a:session, 'exit_code') && a:session.exit_code != 0

        " ログレベルを設定
        let l:log_level = l:is_error ? "error" : "info"

        " vim.notify に送信
        call v:lua.vim.notify(a:data, l:log_level, {"title": "QuickRun"})
    endfunction

    function! s:outputter.finish(session)
    endfunction

    call quickrun#module#register(s:outputter, 1)
    unlet s:outputter

    " Show an in progress animation
    let s:hook = {
    \   "name"         : "in_progress",
    \   "kind"         : "hook",
    \   "index_counter": 0,
    \   "config"       : {
    \       "enable": 0
    \}
    \}

    function! s:hook.on_read(session, context)
        let self.index_counter = -2
    endfunction

    function! s:hook.on_output(session, context)
        let self.index_counter += 1
        if self.index_counter < 0
            return
        endif
        let anime_list = [
       \   '⠋',
       \   '⠙',
       \   '⠹',
       \   '⠸',
       \   '⠼',
       \   '⠴',
       \   '⠦',
       \   '⠧',
       \   '⠇',
       \   '⠏',
       \]
        echo anime_list[ self.index_counter % len(anime_list)]
    endfunction

    call quickrun#module#register(s:hook, 1)
    unlet s:hook

    " General setting
    let g:quickrun_config = get(g:, 'quickrun_config', {})
    let g:quickrun_config._ = {
    \    'runner'                         : 'vimproc',
    \    'runner/vimproc/updatetime'      : 60,
    \    'outputter'                      : 'notify',
    \    'outputter/error/success'        : 'buffer',
    \    'outputter/error/error'          : 'quickfix',
    \    'outputter/buffer/split'         : 'rightbelow 8sp',
    \    'outputter/buffer/close_on_empty': 0,
    \    'hook/in_progress/enable'        : 1,
    \}

    " For LaTeX
    let g:quickrun_config['tex'] = {
    \    'command'                : 'latexmk',
    \    'outputter'              : 'error',
    \    'outputter/error/success': 'quickfix',
    \    'outputter/error/error'  : 'buffer',
    \    'srcfile'                : expand("%"),
    \    'cmdopt'                 : '',
    \    'hook/sweep/files'       : [
    \        '%S:p:r.aux',
    \        '%S:p:r.bbl',
    \        '%S:p:r.blg',
    \        '%S:p:r.dvi',
    \        '%S:p:r.fdb_latexmk',
    \        '%S:p:r.fls',
    \        '%S:p:r.log',
    \        '%S:p:r.out',
    \    ],
    \    'exec'                   : '%c %o %a %s',
    \}
'''
#_____________________________________________________________ End vim-quickrun

[plugins.ftplugin]
tex_plaintex_latex = '''
    set shiftwidth=2

    "autocmd MyAutoCmd FileType tex call <SID>TeXKeymap()
    autocmd MyAutoCmd FileType tex
        \ autocmd BufWritePre <buffer> call <SID>FixPunctuation()

    "function! s:TeXKeymap() abort
    "    inoremap \mr<SPACE> \mathrm{}<LEFT>
    "endfunction

    function! s:FixPunctuation() abort
        let l:pos = getpos('.')
        " その他の句点を全角ピリオドに変換
        silent! execute ':%s/[。]/．/g'
        silent! execute ':%s/、/，/g'
        silent! execute ':%s/\\\@<!\s\+$//'
        setlocal modified
        call setpos('.', l:pos)
    endfunction
'''

lua = '''
    set shiftwidth=2
'''

markdown = '''
    autocmd MyAutoCmd FileType markdown call s:MDKeymap()
    autocmd MyAutoCmd FileType markdown
        \ autocmd BufWritePre <buffer> call s:FixPunctuation()
    function! s:MDKeymap() abort
        inoremap \mr<SPACE> \mathrm{}<LEFT>
    endfunction
    function! s:FixPunctuation() abort
        let l:pos = getpos('.')
        silent! execute ':%s/。/./g'
        silent! execute ':%s/、/,/g'
        silent! execute ':%s/\\\@<!\s\+$//'
        setlocal modified
        call setpos('.', l:pos)
    endfunction
'''

toml = '''
    setl foldmethod=expr
    setl foldexpr=<SID>fold_expr(v:lnum)

    function! s:fold_expr(lnum) abort
        let line = getline(a:lnum)
        return line ==# '' || line[0:3] ==# '    '
    endfunction
'''

#_____________________________________________________________ Start snippets
[[plugins]]
repo = 'rafamadriz/friendly-snippets'

[[plugins]]
repo = 'L3MON4D3/LuaSnip'
depends = ['friendly-snippets']
on_event = 'InsertEnter'
tag = 'v2.*'
build = 'make install_jsregexp'
lua_source = '''
local luasnip = require("luasnip")

-- Configuration
luasnip.config.set_config({
    history = true,
    enable_autosnippets = false,
})

require('luasnip.loaders.from_vscode').lazy_load({
    paths = {
        vim.fn.expand('~/.config/nvim/mySnippets'),
        vim.fn.expand('~/.cache/dein/repos/github.com/rafamadriz/friendly-snippets'),
    },
})

vim.keymap.set('n', '<leader>es', require("luasnip.loaders").edit_snippet_files, { desc = "Edit snippets" })

-- Basic key mapping for expansion
vim.keymap.set({"i"}, "<C-K>", function() luasnip.expand() end)
-- vim.keymap.set({"i", "s"}, "<C-p>", function() luasnip.jump( 1) end)
-- vim.keymap.set({"i", "s"}, "<C-n>", function() luasnip.jump(-1) end)

vim.keymap.set({"i", "s"}, "<C-E>", function()
    if luasnip.choice_active() then
        luasnip.change_choice(1)
    end
end)
'''

hook_post_source = '''
    call ddc#custom#patch_buffer('sources', ['lsp', 'luasnip'])

    call ddc#custom#patch_buffer('sourceParams', {
    \  'lsp' : {
    \       'snippetEngine': denops#callback#register({
    \           body -> luasnip#anonymous(body)
    \       }),
    \       'enableResolveItem': v:true,
    \       'enableAdditionalTextEdit': v:true,
    \       'confirmBehavior': 'replace',
    \     },
    \ })

    call ddc#custom#patch_buffer('sourceOptions', {
    \    'luasnip': {
    \        'mark': '[LS]',
    \        'dup': v:false,
    \    },
    \})
'''
[[plugins]]
repo = 'honza/vim-snippets'

[[plugins]]
repo = 'hrsh7th/vim-vsnip-integ'

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
#_____________________________________________________________ End snippets

#_____________________________________________________________ Start Obsidian
[[plugins]]
repo = 'obsidian-nvim/obsidian.nvim'
on_event = ['BufRead', 'BufNewFile']
on_if = 'expand("%:p") =~# "^" . expand("$OBSIDIAN_PATH") . ".*\\.md$"'
depends = ['plenary.nvim', 'fzf-lua']
lua_source = '''
require('dein.obsidian')
'''
#_____________________________________________________________ End Obsidian

#_____________________________________________________________ Start noice
[[plugins]]
repo = 'folke/noice.nvim'
on_event = 'CmdlineEnter'
depends = ['nui.nvim', 'nvim-notify', 'nvim-treesitter', 'fzf-lua']
lua_source = '''
require("noice").setup({
  lsp = {
    -- override markdown rendering so that **cmp** and other plugins use **Treesitter**
    override = {
      ["vim.lsp.util.convert_input_to_markdown_lines"] = true,
      ["vim.lsp.util.stylize_markdown"] = true,
      ["cmp.entry.get_documentation"] = true, -- requires hrsh7th/nvim-cmp
    },
  },
  -- you can enable a preset for easier configuration
  presets = {
    bottom_search = true, -- use a classic bottom cmdline for search
    command_palette = true, -- position the cmdline and popupmenu together
    long_message_to_split = true, -- long messages will be sent to a split
    inc_rename = false, -- enables an input dialog for inc-rename.nvim
    lsp_doc_border = false, -- add a border to hover docs and signature help
  },
  cmdline = {
      enabled = true, -- enables the Noice cmdline UI
      view = "cmdline_popup", -- view for rendering the cmdline. Change to `cmdline` to get a classic cmdline at the bottom
      opts = {}, -- global options for the cmdline. See section on views
      ---@type table<string, CmdlineFormat>
      format = {
        -- conceal: (default=true) This will hide the text in the cmdline that matches the pattern.
        -- view: (default is cmdline view)
        -- opts: any options passed to the view
        -- icon_hl_group: optional hl_group for the icon
        -- title: set to anything or empty string to hide
        cmdline = { pattern = "^:", icon = "", lang = "vim" },
        search_down = { kind = "search", pattern = "^/", icon = " ", lang = "regex" },
        search_up = { kind = "search", pattern = "^%?", icon = " ", lang = "regex" },
        filter = { pattern = "^:%s*!", icon = "$", lang = "bash" },
        lua = { pattern = { "^:%s*lua%s+", "^:%s*lua%s*=%s*", "^:%s*=%s*" }, icon = "", lang = "lua" },
        help = { pattern = "^:%s*he?l?p?%s+", icon = "󰋗" },
        input = { view = "cmdline_input", icon = "󰥻 " }, -- Used by input()
      },
    },
    notify = {
        enabled = true,
        view = "notify",
    },
})
'''

[[plugins]]
repo = 'MunifTanjim/nui.nvim'

[[plugins]]
repo = 'rcarriga/nvim-notify'
on_lua = 'notify'
lua_source = '''
    vim.notify = require('notify')
    vim.notify.setup {
        timeout = 3000,
        max_height = function()
            return math.floor(vim.o.lines * 075)
        end,
        max_width = function()
            return math.floor(vim.o.columns * 0.60)
        end,
        level = 0,
        render = 'default',
        stages = "fade_in_slide_out",
        on_open = function(win)
            vim.api.nvim_win_set_config(win, { focusable = false })
        end,
    }

    vim.keymap.set("n", "<leader>cf", function()
    require("notify").dismiss({ silent = true, pending = true })
    end, { desc = "Dismiss all notifications" })
'''

#_____________________________________________________________ End noice
[[plugins]]
repo = 'mattn/vim-sonictemplate'
on_cmd = [ 'Template' ]
hook_source = '''
    let g:sonictemplate_vim_template_dir = expand( '~/.config/nvim/templates' )
'''

[[plugins]]
repo = 'folke/zen-mode.nvim'
on_cmd = [ 'ZenMode' ]
hook_add = '''
nnoremap <silent> <leader>zm :ZenMode<CR>
'''
lua_source = '''
require("zen-mode").setup {
    window = {
        backdrop = 0.95,
        width = 0.5,
        height = 1.0,
        options = {
            signcolumn = "no",
            number = true,
            relativenumber = true,
            foldcolumn = "0",
            list = false,
        },
    },
    plugins = {
        options = {
            enabled = true,
            ruler = false,
            showcmd = false,
        },
    },
}
'''

[[plugins]]
repo = 'AndrewRadev/splitjoin.vim'
on_cmd = ['SplitjoinJoin', 'SplitjoinSplit']
hook_source = '''
    let g:splitjoint_python_argument_split_first_newline = 1
    let g:splitjoint_python_argument_split_last_newline = 1
'''
hook_add = '''
    nnoremap <silent> <Leader>jj :SplitjoinJoin<cr>
    nnoremap <silent> <Leader>js :SplitjoinSplit<cr>
'''

[[plugins]]
repo = 'great-cactus/read-text.vim'
depends = ['denops.vim']
on_map = { ictn = '<Plug>(read-text-' }
hook_add = '''
nmap <leader>rt <Plug>(read-text-from-cursor-async)
vmap <leader>rt <Plug>(read-text-selection-async)
nmap <leader>al <Plug>(read-text-line-async)
'''

hook_source = '''
let g:read_text_voicevox_url = 'https://hideously-cheerful-swift.ngrok-free.app'
let g:read_text_speaker_id = 0
let g:read_text_speed_scale = 1.0
let g:read_text_pitch_scale = 0.0
'''

[[plugins]]
repo = 'm4xshen/autoclose.nvim'
on_event = 'InsertEnter'
lua_source = '''
require('autoclose').setup({
    options = {
        disabled_filetypes = {"text"},
        disable_when_touch = true,
        pair_spaces = false,
        auto_indent = true,
        disable_command_mode = false,
    },
    keys = {
        ["("] = { escape = false, close = true, pair = "()" },
        ["（"] = { escape = false, close = true, pair = "（）" },
        ["["] = { escape = false, close = true, pair = "[]" },
        ["{"] = { escape = false, close = true, pair = "{}" },
        [">"] = { escape = true, close = false, pair = "<>" },
        [")"] = { escape = true, close = false, pair = "()" },
        ["]"] = { escape = true, close = false, pair = "[]" },
        ["}"] = { escape = true, close = false, pair = "{}" },
        ['"'] = { escape = true, close = true, pair = '""' },
        ["'"] = { escape = true, close = true, pair = "''" },
        ["`"] = { escape = true, close = true, pair = "`'", enabled_filetypes = {"tex", "latex"} },
        ["$"] = { escape = true, close = true, pair = "$$", enabled_filetypes = {"markdown", "tex", "latex"} },
    },
})
'''

[[plugins]]
repo = 'OXY2DEV/foldtext.nvim'
on_event = 'BufReadPost'
lua_source = '''
require("foldtext").setup({
    -- Ignore buffers with these buftypes.
    ignore_buftypes = {},
    -- Ignore buffers with these filetypes.
    ignore_filetypes = {},
    -- Ignore buffers/windows if the result
    -- is false.
    condition = function ()
        return true;
    end,

    styles = {
        default = {
            { kind = "bufline" }
        },

        -- Custom foldtext.
        custom_a = {
            -- Only on these filetypes.
            filetypes = {},
            -- Only on these buftypes.
            buftypes = {},

            -- Only if this condition is
            -- true.
            condition = function (win)
                return vim.wo[win].foldmethod == "manual";
            end,

            -- Parts to create the foldtext.
            parts = {
                { kind = "fold_size" }
            }
        }
    }
});
'''

[[plugins]]
repo = 'airblade/vim-gitgutter'
on_map = { ictn = '<Plug>(GitGutter'}
hook_add = '''
nnoremap <leader>x <Cmd>GitGutterBufferToggle<Bar>GitGutterLineHighlightsToggle<Bar>GitGutterLineNrHighlightsToggle<CR>
'''
hook_source = '''
let g:gitgutter_map_keys=0
set updatetime=100

" Hunk navigation
nnoremap ]h <Plug>(GitGutterNextHunk)
nnoremap [h <Plug>(GitGutterPrevHunk)

" Hunk management
nnoremap <leader>hs <Plug>(GitGutterStageHunk)
nnoremap <leader>hu <Plug>(GitGutterUndoHunk)
nnoremap <leader>hp <Plug>(GitGutterPreviewHunk)

" Git diff to quickfix mapping
nnoremap <leader>gq :GitGutterQuickFix<CR>

" Custom highlight settings to prevent text overwrite
augroup GitGutterHighlights
    autocmd!
    " Configure cursor line highlighting without overwriting text highlights
    autocmd ColorScheme * highlight GitGutterAddLine gui=bold cterm=bold guibg=#e6ffe6 ctermbg=194
    autocmd ColorScheme * highlight GitGutterChangeLine gui=bold cterm=bold guibg=#fffae6 ctermbg=230
    autocmd ColorScheme * highlight GitGutterDeleteLine gui=bold cterm=bold guibg=#ffe6e6 ctermbg=224

    " Ensure signs are visible but don't interfere with text
    autocmd ColorScheme * highlight GitGutterAdd guifg=#00aa00 ctermfg=34 gui=bold cterm=bold
    autocmd ColorScheme * highlight GitGutterChange guifg=#bbbb00 ctermfg=3 gui=bold cterm=bold
    autocmd ColorScheme * highlight GitGutterDelete guifg=#aa0000 ctermfg=1 gui=bold cterm=bold
    autocmd ColorScheme * highlight GitGutterChangeDelete guifg=#aa0000 ctermfg=1 gui=bold cterm=bold
augroup END

" Settings for deleted lines visibility when GitGutterLineHighlightsEnable is active
let g:gitgutter_sign_removed = '▶'
let g:gitgutter_sign_removed_first_line = '▲'
let g:gitgutter_sign_removed_above_and_below = '▼'
let g:gitgutter_sign_modified_removed = '▶'
'''

[[plugins]]
repo = 'lukas-reineke/indent-blankline.nvim'
merged = '0'
on_event = 'BufReadPost'
lua_source = '''
require('ibl').setup()
'''

# [[plugins]]
# repo = 'mvllow/modes.nvim'
# on_event = 'InsertEnter'
# lua_source = '''
# require('modes').setup({
#   colors = {
#     bg = "", -- Optional bg param, defaults to Normal hl group
#     copy = "#f5c359",
#     delete = "#c75c6a",
#     change = "#c75c6a", -- Optional param, defaults to delete
#     format = "#c79585",
#     insert = "#e4f4f3",
#     replace = "#245361",
#     select = "#9745be", -- Optional param, defaults to visual
#     visual = "#9745be",
#   },
#
#   -- Set opacity for cursorline and number background
#   line_opacity = 0.15,
#
#   -- Enable cursor highlights
#   set_cursor = true,
#
#   -- Enable cursorline initially, and disable cursorline for inactive windows
#   -- or ignored filetypes
#   set_cursorline = true,
#
#   -- Enable line number highlights to match cursorline
#   set_number = false,
#
#   -- Enable sign column highlights to match cursorline
#   set_signcolumn = true,
#
#   -- Disable modes highlights for specified filetypes
#   -- or enable with prefix "!" if otherwise disabled (please PR common patterns)
#   -- Can also be a function fun():boolean that disables modes highlights when true
#   ignore = { 'NvimTree', 'TelescopePrompt', '!minifiles' }
# })
# '''
